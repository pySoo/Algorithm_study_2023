## [Level 2] 두 큐 합 같게 만들기 - 118667

[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/118667)

### 구분

코딩테스트 연습 > 2022 카카오 테크 인턴십

### 풀이 요약

그리디 알고리즘을 이용해서 풀이하는 문제였습니다. 큐의 합을 같게 만들기 위해서는 위 두 가지 방법만 고려하면 됩니다.

1. 왼쪽 큐의 합 < 오른쪽 큐의 합이라면, 왼쪽 큐의 원소를 오른쪽 큐에 넘겨줍니다.
2. 왼쪽 큐의 합 > 오른쪽 큐의 합이라면, 오른쪽 큐의 원소를 왼쪽 큐에 넘겨줍니다.

여기서 원소를 넘겨주는 작업을 할 때, 리스트의 pop(0)을 사용하면 시간 초과가 발생하므로 deque 자료구조를 사용하여 popleft()를 활용해주는 것이 필요합니다!

어려웠던 점은 합을 같게 만들 수 없는 조건을 구하는 것이었습니다. 문제를 작게 쪼개어서 [1,1] [1,5]의 큐가 주어진 경우를 고려해보았습니다. 두 큐의 자리를 바꾸기 위해서는 4번의 계산이 필요하고, 다시 원래 자리로 돌리기 위해서는 8번의 계산이 필요했습니다. 8번은 큐의 길이 x 4로 표현할 수 있습니다.

따라서, 원래 위치로 돌아오는 경우인 4n번의 계산이 지난 경우 합을 같게 만들 수 없다고 판단하고 -1을 리턴합니다.

- 홀수의 경우도 2로 나눌 수 없으므로 예외 처리를 해준다면 더 센스있는 풀이가 되겠습니다! (저는 생각을 못했네요..!)

### 나의 풀이

```python
from collections import deque

def solution(queue1, queue2):
    answer = 0
    queue1, queue2 = deque(queue1), deque(queue2)
    sum1, sum2 = sum(queue1), sum(queue2)

    if (sum1 + sum2) % 2 != 0:
        return -1

    for _ in range(4 * len(queue1)):
        if sum1 > sum2:
            sum1 -= queue1[0]
            sum2 += queue1[0]
            queue2.append(queue1.popleft())
        elif sum1 < sum2:
            sum1 += queue2[0]
            sum2 -= queue2[0]
            queue1.append(queue2.popleft())
        elif sum1 == sum2:
            return answer
        answer += 1
    return -1
```

### 배운 점

그리디 알고리즘 적용에 조금 더 익숙해진 것 같습니다. 신기하게도 바로 전에 풀었던 문제가 2023 카카오 블라인드의 "택배 배달과 수거하기" 문제였는데, 이 문제도 그리디를 이용해서 푸는 문제였습니다. (우와)

카카오 기출 문제를 위주로 풀다보니 문자열을 이용한 구현 문제 풀이에 익숙해져있었는데, 이제는 그리디 문제를 많이 풀어보아야 할 것 같다는 생각이 듭니다. 실제로도 한빛 미디어에서 조사한 결과 코딩테스트 기출 문제 유형의 1,2,3위가 구현, BFS/DFS, 그리디였습니다.

요즘 추세는 (빡센) 구현 문제로 주어진 요구사항을 얼마나 잘 구현할 수 있냐를 보고싶어 하는 것 같지만.. 그리디 문제의 경우 처음에는 아이디어를 떠올리는 것조차 어렵게 느껴지기 때문에 문제를 많이 풀면서 이쪽도 대비를 해놓아야 한다는 생각이 들었습니다. 역시 코테 준비는 꾸준히 문제를 풀어내는게 가장 중요한 것 같습니다. 요즘은 새벽에 로파이나 재즈를 들으면서 평온하게 문제를 풀어내는 이 시간을 기다리게 됩니다..ㅋㅋㅋㅋ 알고리즘.. 꽤나 적성에 맞을지도,,

### 문제 설명

길이가 같은 두 개의 큐가 주어집니다. 하나의 큐를 골라 원소를 추출(pop)하고, 추출된 원소를 다른 큐에 집어넣는(insert) 작업을 통해 각 큐의 원소 합이 같도록 만들려고 합니다. 이때 필요한 작업의 최소 횟수를 구하고자 합니다. 한 번의 pop과 한 번의 insert를 합쳐서 작업을 1회 수행한 것으로 간주합니다.

큐는 먼저 집어넣은 원소가 먼저 나오는 구조입니다. 이 문제에서는 큐를 배열로 표현하며, 원소가 배열 앞쪽에 있을수록 먼저 집어넣은 원소임을 의미합니다. 즉, pop을 하면 배열의 첫 번째 원소가 추출되며, insert를 하면 배열의 끝에 원소가 추가됩니다. 예를 들어 큐 [1, 2, 3, 4]가 주어졌을 때, pop을 하면 맨 앞에 있는 원소 1이 추출되어 [2, 3, 4]가 되며, 이어서 5를 insert하면 [2, 3, 4, 5]가 됩니다.

길이가 같은 두 개의 큐를 나타내는 정수 배열 queue1, queue2가 매개변수로 주어집니다. 각 큐의 원소 합을 같게 만들기 위해 필요한 작업의 최소 횟수를 return 하도록 solution 함수를 완성해주세요. 단, 어떤 방법으로도 각 큐의 원소 합을 같게 만들 수 없는 경우, -1을 return 해주세요.

<h4>제한사항</h4>

- 1 ≤ queue1의 길이 = queue2의 길이 ≤ 300,000
- 1 ≤ queue1의 원소, queue2의 원소 ≤ 109
- 주의: 언어에 따라 합 계산 과정 중 산술 오버플로우 발생 가능성이 있으므로 long type 고려가 필요합니다.

<h4>입출력 예</h4>
<table>
        <thead><tr>
<th>queue1</th>
<th>queue2</th>
<th>result</th>
</tr>
</thead>
        <tbody>
<tr>
<td>[3, 2, 7, 2]</td>
<td>[4, 6, 5, 1]</td>
<td>2</td>
</tr>
</tbody>
      </table>
