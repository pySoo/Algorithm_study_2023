## [Level 3] 자물쇠와 열쇠 - 60059

[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/60059)

### 구분

코딩테스트 연습 > 카카오 2020 블라인드 1차

### 풀이 요약

2차원 배열의 이동과 회전을 이용해서 풀어야 하는 구현 문제였습니다. 풀이 과정은 다음과 같습니다.

1. M \* 2 + N 크기의 보드를 만들고 중간에 자물쇠를 배치합니다.
   - (열쇠가 끄트머리부터 이동할 수 있게 하기 위함)
2. key를 4번 돌려가면서 차례로 이동시킵니다.
3. 중앙의 자물쇠가 모두 1이 되면 열 수 있다고 판단합니다.

열쇠가 항상 자물쇠의 (0,0) 위치부터 시작하는 것이 아니라 열쇠의 마지막 요소(3,3)가 (0,0) 위치에 걸칠 수도 있는 상황임을 인지하는게 중요한 문제였습니다. 그렇기 때문에 열쇠의 크기만큼 보드를 상하좌우로 확장시켜주는게 중요한 포인트였습니다.

### 나의 풀이

```python
import copy

def rotate_90(board):
    return list(zip(*board[::-1]))

def compare_key(m, board):
    n = len(board) - 2 * m
    for i in range(n):
        for j in range(n):
            if board[m+i][m+j] != 1:
                return False
    return True


def is_locked(m, i, j, key, board):
    copy_board = copy.deepcopy(board)
    for x in range(m):
        for y in range(m):
            nx, ny = x+i, y+j
            if copy_board[nx][ny] == 1 and key[x][y] == 1:
                return False
            if copy_board[nx][ny] == 0 and key[x][y] == 1:
                copy_board[nx][ny] = key[x][y]
    return compare_key(m, copy_board)


def solution(key, lock):
    answer = False
    n, m = len(lock), len(key)
    board = [[0] * (n + 2 * m) for _ in range(n + 2 * m)]

    for i in range(n):
        for j in range(n):
            board[i+m][j+m] = lock[i][j]


    rotated_key = key
    for i in range(4):
        rotated_key = rotate_90(rotated_key)
        for x in range(1,m+n):
            for y in range(1,m+n):
                if is_locked(m, x, y, rotated_key, board):
                    return True
    return answer
```

### 배운 점

**2차원 배열을 회전하고 이동**시키는 것에 조금 익숙해진 것 같습니다. 2차원 배열을 이동시킬 때 범위를 정하거나 회전시키는 것에 취약하다는 생각이 들었기 때문에 요근래에는 2차원 배열 문제를 많이 풀어봤습니다.

역시나 이번 문제도 쉽지 않았습니다..! 하지만 비슷한 유형을 꾸준히 풀다보면 나중에 시험장에서 해당 유형을 접했을 때 아이디어를 떠올릴 수 있을 것이라는 희망을 가지고 있습니다.

그리고 다시 한 번 느낀거지만 구현 문제는 **문제를 꼼꼼히 읽는 것이 중요**합니다. 로직을 다 구현했다고 생각했지만 자물쇠와 열쇠가 모두 1 값을 가져서 홈이 부딪힌 경우의 예외 케이스를 처리해주지 않아서 틀리곤 했습니다.

내일 있는 시험에서는 **요구사항 리스트를 작성해서 하나하나 체크해가면서 꼼꼼하게 풀어야겠습니다.** 정말 간절한만큼 실수하지 않고 침착하게 잘 풀어나갈 수 있었으면 좋겠습니다. 이번 시험으로 최종 결과가 정해진다고 생각하니까 더더욱 떨리지만.. 😭 시험을 보기 전까지는 그동안 풀었던 문제를 복습하면서 할 수 있는 최선을 다해보려고 합니다.

### 문제 설명

고고학자인 "튜브"는 고대 유적지에서 보물과 유적이 가득할 것으로 추정되는 비밀의 문을 발견하였습니다. 그런데 문을 열려고 살펴보니 특이한 형태의 **자물쇠**로 잠겨 있었고 문 앞에는 특이한 형태의 **열쇠**와 함께 자물쇠를 푸는 방법에 대해 다음과 같이 설명해 주는 종이가 발견되었습니다.

잠겨있는 자물쇠는 격자 한 칸의 크기가 **`1 x 1`**인 **`N x N`** 크기의 정사각 격자 형태이고 특이한 모양의 열쇠는 **`M x M`** 크기인 정사각 격자 형태로 되어 있습니다.

자물쇠에는 홈이 파여 있고 열쇠 또한 홈과 돌기 부분이 있습니다. 열쇠는 회전과 이동이 가능하며 열쇠의 돌기 부분을 자물쇠의 홈 부분에 딱 맞게 채우면 자물쇠가 열리게 되는 구조입니다. 자물쇠 영역을 벗어난 부분에 있는 열쇠의 홈과 돌기는 자물쇠를 여는 데 영향을 주지 않지만, 자물쇠 영역 내에서는 열쇠의 돌기 부분과 자물쇠의 홈 부분이 정확히 일치해야 하며 열쇠의 돌기와 자물쇠의 돌기가 만나서는 안됩니다. 또한 자물쇠의 모든 홈을 채워 비어있는 곳이 없어야 자물쇠를 열 수 있습니다.

열쇠를 나타내는 2차원 배열 key와 자물쇠를 나타내는 2차원 배열 lock이 매개변수로 주어질 때, 열쇠로 자물쇠를 열수 있으면 true를, 열 수 없으면 false를 return 하도록 solution 함수를 완성해주세요.

### 제한사항

- key는 M x M(3 ≤ M ≤ 20, M은 자연수)크기 2차원 배열입니다.
- lock은 N x N(3 ≤ N ≤ 20, N은 자연수)크기 2차원 배열입니다.
- M은 항상 N 이하입니다.
- key와 lock의 원소는 0 또는 1로 이루어져 있습니다.
  - 0은 홈 부분, 1은 돌기 부분을 나타냅니다.
