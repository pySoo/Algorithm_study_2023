## 뒤집기 - 1439

[문제 링크](https://www.acmicpc.net/problem/1439)

### 구분

문자열, 그리디

### 풀이 요약

그리디를 이용해서 푸는 방법은 다음과 같습니다. 뒤집는 숫자의 개수가 얼마나 많던지 상관없이 숫자가 얼마나 바뀌는지만 계산합니다. 따라서 이전 문자와 다르다면 카운트를 증가시켜줍니다.

문자열을 변환해서 푸는 방법은 다음과 같습니다. 연속된 숫자는 제거해서 새로운 문자열에 담고, 새로운 문자열에서 1과 0의 개수를 카운트 한 뒤 작은 수를 반환합니다.

### 나의 풀이

```python
# 그리디를 이용한 풀이

s = input()
count = 0
for i in range(len(s) - 1):
    if s[i] != s[i+1]:
        count += 1
print((count + 1) // 2)

```

```python
# 문자열 변환을 이용한 풀이
answer = 0
s = input()
convert_num = s

result = ''
for n in convert_num:
  if not result or result[-1] != n:
    result += n

print(min(result.count('0'), result.count('1')))
```

### 배운 점

그리디 문제를 쭉 풀어보기로 계획했기 때문에 그리디 문제인 것은 알고 있었으나, 그리디를 적용한 풀이를 떠올리는 것은 쉽지 않았습니다. 그래서 처음에는 규칙을 발견해서 문자열을 변환하는 방법으로 풀이했습니다. 그 후에 다른 분들의 그리디 풀이를 참고하면서 `숫자가 얼마나 바뀌는지만 계산`하는 방법을 알게 되었습니다.

하지만 마지막 과정에서 (count + 1) // 2 의 계산과정이 잘 이해가 되지 않았고, 이러한 계산법이 나온 이유는 변화한 횟수와 뒤집는 횟수를 나열하다보면 발견되는 규칙이라는 글을 읽게 되었습니다.

문제를 작게 쪼개서 규칙을 발견하는 과정에 대해서는 동의하지만, 규칙을 끝까지 나열하여야 마지막 계산법을 설명할 수 있기 때문에 이해가 쉽지 않다고 느꼈습니다. 게다가 실제 시험장에서도 이러한 그리디 풀이를 떠올릴 수 있을까라는 생각이 크게 들었기 때문에 처음 제가 떠올린 답안을 제출하기로 결정했습니다.

이번 문제를 풀면서 배운 점은 그리디를 적용하는 방법도 있었지만 적절한 풀이 방법을 선택하는 기준을 세울 수 있었다는 점입니다. 그리디를 적용해서 풀 수 있는 문제라도 풀이할 수 있는 방법이 정해진 것은 아니기 때문에, 유연하게 사고하되 명확하게 설명할 수 있는 코드를 우선시하여 작성해보자는 생각이 들었습니다.

그럼에도 시험 유형에 자주 나오는... 애증의 그리디와 더 친해지고 싶기 때문에.. 앞으로도 그리디 유형 문제를 꾸준히 풀어보려고 합니다.

### 문제 설명

다솜이는 0과 1로만 이루어진 문자열 S를 가지고 있다. 다솜이는 이 문자열 S에 있는 모든 숫자를 전부 같게 만들려고 한다. 다솜이가 할 수 있는 행동은 S에서 연속된 하나 이상의 숫자를 잡고 모두 뒤집는 것이다. 뒤집는 것은 1을 0으로, 0을 1로 바꾸는 것을 의미한다.

예를 들어 S=0001100 일 때,

전체를 뒤집으면 1110011이 된다.
4번째 문자부터 5번째 문자까지 뒤집으면 1111111이 되어서 2번 만에 모두 같은 숫자로 만들 수 있다.
하지만, 처음부터 4번째 문자부터 5번째 문자까지 문자를 뒤집으면 한 번에 0000000이 되어서 1번 만에 모두 같은 숫자로 만들 수 있다.

문자열 S가 주어졌을 때, 다솜이가 해야하는 행동의 최소 횟수를 출력하시오.

<h4>입력</h4>
첫째 줄에 문자열 S가 주어진다. S의 길이는 100만보다 작다.

<h4>출력</h4>
첫째 줄에 다솜이가 해야하는 행동의 최소 횟수를 출력한다.

<h4>예제 입력 1</h4>
11001100110011000001

<h4>예제 출력 1</h4>
4
