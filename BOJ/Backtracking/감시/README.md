## 감시 - 15683

[문제 링크](https://www.acmicpc.net/problem/15683)

### 구분

구현, 브루트포스, 백트래킹

### 풀이 요약

cctv의 모든 방향의 경우를 탐색해서 최소한의 사각지대를 만드는 백트래킹 문제였습니다.
그림이 포함된 긴 글을 해석해서 구현하는 일명 빡구현 문제를 연습하려고 했는데 백트래킹 개념이 섞여있어서 아주 호되게 혼났습니다. 😂

풀이 과정은 다음과 같습니다.

1. cctv 번호 별로 방향 배열을 지정해줍니다. 방향은 dx dy를 배열을 참조합니다. (mode)
2. cctv 번호와 좌표에 대한 배열을 만들고 1번 cctv부터 마지막 cctv까지의 모든 경우를 탐색합니다. (dfs)
3. cctv로 감시할 수 있는 경우 0을 -1로 변경해줍니다.
4. 마지막 cctv까지 탐색한 경우에 0을 count해서 사각지대의 개수를 구하고, 이전 정답과 비교하여 최소값을 정답으로 저장합니다.

### 나의 풀이

```Python
import sys
import copy

input = sys.stdin.readline

n, m = map(int, input().split())

board = []
cctv = []
for i in range(n):
  row = list(map(int, input().split()))
  board.append(row)
  for j in range(m):
    if row[j] in [1, 2, 3, 4, 5]:
      cctv.append([row[j], i, j])

# 상하좌우
dx = [-1,0,1,0]
dy = [0,1,0,-1]

mode = {
  1: [[0], [1], [2], [3]],
  2: [[0, 2], [1, 3]],
  3: [[0, 1], [1, 2], [2, 3], [0, 3]],
  4: [[0, 1, 2], [0, 1, 3], [1, 2, 3], [0, 2, 3]],
  5: [[0, 1, 2, 3]],
}

def check_cctv(board, direction, x, y):
  row, col = len(board), len(board[0])
  for i in direction:
    nx, ny = x, y
    while True:
      nx += dx[i]
      ny += dy[i]
      if nx < 0 or ny < 0 or nx >= row or ny >= col:
        break
      if board[nx][ny] == 6:
        break
      elif board[nx][ny] == 0:
        board[nx][ny] = -1

def dfs(depth, board):
  global answer
  if depth == len(cctv):
    count = 0
    for i in range(n):
      count += board[i].count(0)
    answer = min(answer, count)
    return

  copy_board = copy.deepcopy(board)
  cctv_num, x, y = cctv[depth]
  for direction in mode[cctv_num]:
    check_cctv(copy_board, direction, x, y)
    dfs(depth+1, copy_board)
    copy_board = copy.deepcopy(board)

answer = n * m
dfs(0, board)
print(answer)
```

### 배운 점

dfs를 이용해서 모든 경우의 수를 탐색하는 법을 배울 수 있었습니다. 처음에는 cctv 별로 방문한 경로를 저장한 뒤 경로들의 조합을 구해서 풀이하려 했습니다. 하지만 여러개의 리스트에 대한 조합을 만드는 것이 어려웠습니다. 모든 경우의 수를 계산해야 한다는 기본 전제는 변하지 않으므로 dfs를 이용해서 풀자는 아이디어를 떠올릴 수 있었습니다. 앞으로 모든 경우의 수를 탐색 해야할 때는 dfs의 재귀를 활용하는 법을 적용해볼 수 있을 것 같습니다.

### 문제 설명

월드컵 조별 최종 예선에서는 6개국으로 구성된 각 조별로 동일한 조에 소속된 국가들과 한 번씩, 각 국가별로 총 5번의 경기를 치른다. 조별리그가 끝난 후, 기자가 보내온 각 나라의 승, 무승부, 패의 수가 가능한 결과인지를 판별하려고 한다.

네 가지의 결과가 주어질 때 각각의 결과에 대하여 가능하면 1, 불가능하면 0을 출력하는 프로그램을 작성하시오.

### 입력

스타트링크의 사무실은 1×1크기의 정사각형으로 나누어져 있는 N×M 크기의 직사각형으로 나타낼 수 있다. 사무실에는 총 K개의 CCTV가 설치되어져 있는데, CCTV는 5가지 종류가 있다. 각 CCTV가 감시할 수 있는 방법은 다음과 같다.

1번 CCTV는 한 쪽 방향만 감시할 수 있다. 2번과 3번은 두 방향을 감시할 수 있는데, 2번은 감시하는 방향이 서로 반대방향이어야 하고, 3번은 직각 방향이어야 한다. 4번은 세 방향, 5번은 네 방향을 감시할 수 있다.

CCTV는 감시할 수 있는 방향에 있는 칸 전체를 감시할 수 있다. 사무실에는 벽이 있는데, CCTV는 벽을 통과할 수 없다. CCTV가 감시할 수 없는 영역은 사각지대라고 한다.

CCTV는 회전시킬 수 있는데, 회전은 항상 90도 방향으로 해야 하며, 감시하려고 하는 방향이 가로 또는 세로 방향이어야 한다.

0 0 0 0 0 0
0 0 0 0 0 0
0 0 1 0 6 0
0 0 0 0 0 0
지도에서 0은 빈 칸, 6은 벽, 1~5는 CCTV의 번호이다. 위의 예시에서 1번의 방향에 따라 감시할 수 있는 영역을 '#'로 나타내면 아래와 같다.

0 0 0 0 0 0
0 0 0 0 0 0
0 0 1 # 6 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0

CCTV는 벽을 통과할 수 없기 때문에, 1번이 → 방향을 감시하고 있을 때는 6의 오른쪽에 있는 칸을 감시할 수 없다.

0 0 0 0 0 0
0 2 0 0 0 0
0 0 0 0 6 0
0 6 0 0 2 0
0 0 0 0 0 0
0 0 0 0 0 5

사무실의 크기와 상태, 그리고 CCTV의 정보가 주어졌을 때, CCTV의 방향을 적절히 정해서, 사각 지대의 최소 크기를 구하는 프로그램을 작성하시오.

### 입력

첫째 줄에 사무실의 세로 크기 N과 가로 크기 M이 주어진다. (1 ≤ N, M ≤ 8)

둘째 줄부터 N개의 줄에는 사무실 각 칸의 정보가 주어진다. 0은 빈 칸, 6은 벽, 1~5는 CCTV를 나타내고, 문제에서 설명한 CCTV의 종류이다.

CCTV의 최대 개수는 8개를 넘지 않는다.

### 출력

첫째 줄에 사각 지대의 최소 크기를 출력한다.

### 예제 입력1

```
4 6
0 0 0 0 0 0
0 0 0 0 0 0
0 0 1 0 6 0
0 0 0 0 0 0
```

### 예제 출력 1

```
20
```
