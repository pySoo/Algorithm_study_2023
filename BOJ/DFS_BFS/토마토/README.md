## 토마토 - 7576

[문제 링크](https://www.acmicpc.net/problem/7576)

### 구분

그래프 탐색, BFS

### 풀이 요약

BFS를 이용하여 익은 토마토의 인접한 토마토들을 익혀나가면서 전체 토마토가 익을 때까지 걸리는 최소 일수를 구하는 문제입니다.

'최소 일수'와 '인접한 토마토를 익힘'이라는 키워드로 DFS가 아닌 BFS로 풀어야 하는 문제임을 판단했습니다.

BFS 구현에서 큐를 만들어 줄 때 파이썬의 deque 자료구조를 사용하여야 시간 초과를 막을 수 있었습니다. 리스트의 pop()과 deque의 popleft() 연산은 O(n)과 O(1) 정도의 차이가 있습니다.

### 나의 풀이

```python
import sys
from collections import deque

day = -1
input = sys.stdin.readline
box = []
ripe = deque()
dx = [-1,1,0,0]
dy = [0,0,-1,1]

m, n = map(int, input().split())
for _ in range(n):
    box.append(list(map(int,input().split())))

def bfs():
  while ripe:
    x, y = ripe.popleft()
    for i in range(4):
      nx, ny = x + dx[i], y + dy[i]
      if nx >= 0 and nx < n and ny >= 0 and ny < m:
        if box[nx][ny] == 0:
          box[nx][ny] += box[x][y] + 1
          ripe.append([nx,ny])


for row in range(n):
  for col in range(m):
    if box[row][col] == 1:
      ripe.append([row,col])

bfs()

for row in range(n):
  max_day = max(box[row]) - 1
  if 0 in box[row]:
    day = -1
    break
  else:
    if max_day > day:
      day = max_day

print(day)
```

### 배운 점

첫 시도에서는 1을 만날 때마다(익은 토마토) bfs를 돌려서 풀이했습니다. 모든 토마토를 익히는 것에는 성공했지만 날짜가 맞지 않는 케이스가 있어서 당황했습니다. 그 이유는 익은 토마토가 여러 개 주어졌을 때 **토마토를 익히는 작업을 동시에 처리하지 못하기 때문**이었습니다.

```
6 4
1 -1 0 0 0 0
0 -1 0 0 0 0
0 0 0 0 -1 0
0 0 0 0 -1 1
```

예를 들어, 이 케이스에서는 [0,0]의 영향으로 [1,0]이 익게 되고(day2) [1,0]의 영향으로 [2,0]이 익게 되고(day3)..의 과정을 반복하게 됩니다. 여기서 중요한 점은 [5,3]의 영향으로 [4,3]도 day2에 익게 되었지만 [0,0]에 대한 bfs문의 큐에는 [5,3]이 없기 때문에 익은 토마토 처리가 되지 않았습니다.

따라서 bfs문을 어떤 조건에서 처리해주어야 하는지에 대한 고민을 했고, 익은 토마토들만 먼저 큐에 넣어준 후 해당 큐에 대해 bfs 연산을 처리하는 아이디어를 떠올렸습니다. 최소 일수에 대한 계산은 배열에서 가장 숫자가 높은 값이 마지막 날이라고 생각했고 첫 계산을 1일에서 시작하였기 때문에 1을 빼주어서 최소 일수를 구하였습니다.

그래프 문제를 풀 때는 bfs/dfs 중 어떤 탐색을 적용할 것인지와 해당 알고리즘을 어떤 조건에서 실행할 것인지에 대한 논리적인 판단이 필요한 것 같습니다. 여담으로 저는 그래프 문제를 좋아합니다.. ㅎㅎ 탐색을 돌릴 때마다 리스트를 출력해서 확인하고는 하는데 정답까지 달려가는 여정을 보는게 재밌기도 하고 마지막 리스트가 정답이랑 일치할 때의 그 희열이 참 짜릿합니다,, 그리디 문제에서 마구마구 혼쭐이 나다가 그래프로 돌아오니 고향에 돌아온 느낌이라 좋습니다.

### 문제 설명

철수의 토마토 농장에서는 토마토를 보관하는 큰 창고를 가지고 있다. 토마토는 아래의 그림과 같이 격자 모양 상자의 칸에 하나씩 넣어서 창고에 보관한다.

창고에 보관되는 토마토들 중에는 잘 익은 것도 있지만, 아직 익지 않은 토마토들도 있을 수 있다. 보관 후 하루가 지나면, 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다. 하나의 토마토의 인접한 곳은 왼쪽, 오른쪽, 앞, 뒤 네 방향에 있는 토마토를 의미한다. 대각선 방향에 있는 토마토들에게는 영향을 주지 못하며, 토마토가 혼자 저절로 익는 경우는 없다고 가정한다. 철수는 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지, 그 최소 일수를 알고 싶어 한다.

토마토를 창고에 보관하는 격자모양의 상자들의 크기와 익은 토마토들과 익지 않은 토마토들의 정보가 주어졌을 때, 며칠이 지나면 토마토들이 모두 익는지, 그 최소 일수를 구하는 프로그램을 작성하라. 단, 상자의 일부 칸에는 토마토가 들어있지 않을 수도 있다.

### 입력

첫 줄에는 상자의 크기를 나타내는 두 정수 M,N이 주어진다. M은 상자의 가로 칸의 수, N은 상자의 세로 칸의 수를 나타낸다. 단, 2 ≤ M,N ≤ 1,000 이다. 둘째 줄부터는 하나의 상자에 저장된 토마토들의 정보가 주어진다. 즉, 둘째 줄부터 N개의 줄에는 상자에 담긴 토마토의 정보가 주어진다. 하나의 줄에는 상자 가로줄에 들어있는 토마토의 상태가 M개의 정수로 주어진다. 정수 1은 익은 토마토, 정수 0은 익지 않은 토마토, 정수 -1은 토마토가 들어있지 않은 칸을 나타낸다.

토마토가 하나 이상 있는 경우만 입력으로 주어진다.

### 출력

여러분은 토마토가 모두 익을 때까지의 최소 날짜를 출력해야 한다. 만약, 저장될 때부터 모든 토마토가 익어있는 상태이면 0을 출력해야 하고, 토마토가 모두 익지는 못하는 상황이면 -1을 출력해야 한다.

### 예제 입력 1

```
6 4
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 1
```

### 예제 출력 1

```
8
```

### 예제 입력 2

```
6 4
0 -1 0 0 0 0
-1 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 1
```

### 예제 출력 2

```
-1
```

### 예제 입력 3

```
2 2
1 -1
-1 1
```

### 예제 입력

```
0
```
